function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}var EMPTY_STATE="emptyState";var UPDATE_CAN_UNDO_REDO="updateCanUndoRedo";var REDO="redo";var UNDO="undo";/**
 * Piping async action calls secquentially using Array.prototype.reduce
 * to chain and initial, empty promise
 *
 * @module store/plugins/undoRedo:getConfig
 * @function
 * @param {String} namespace - The name of the store module
 * @returns {Object} config - The object containing the undo/redo stacks of the store module
 */var getConfig=function(a){return function(b){return a.find(function(a){return a.namespace===b})||{}}};// Based on https://gist.github.com/anvk/5602ec398e4fdc521e2bf9940fd90f84
/**
 * Piping async action calls secquentially using Array.prototype.reduce
 * to chain and initial, empty promise
 *
 * @module store/plugins/undoRedo:pipeActions
 * @function
 * @param {Array<Object>} actions - The array of objects containing the each
 * action's name and payload
 */var pipeActions=function(a){return function(b){return b.filter(function(a){var b=a.action;return !!b}).reduce(function(b,c){var d=c.action,e=c.payload;return b.then(function(){return a.dispatch(d,e)})},Promise.resolve())}};/**
 * Piping async action calls secquentially using Array.prototype.reduce
 * to chain and initial, empty promise
 *
 * @module store/plugins/undoRedo:setConfig
 * @function
 * @param {String} [namespace] - The name of the store module
 * @param {Object} config - The object containing the updated undo/redo stacks of the store module
 */var setConfig=function(a){return function(b,c){var d=a.findIndex(function(a){return a.namespace===b});a.splice(d,1,c);}};var canRedo=function(a){return function(b){var c=getConfig(a)(b);return !!Object.keys(c).length&&0<c.undone.length}},canUndo=function(a){return function(b){var c=getConfig(a)(b);return !!c&&0<c.done.length}};var updateCanUndoRedo=function(a){var b=a.paths,c=a.store;return function(a){var d=canUndo(b)(a),e=canRedo(b)(a);c.commit("".concat(a).concat(UPDATE_CAN_UNDO_REDO),{canUndo:d}),c.commit("".concat(a).concat(UPDATE_CAN_UNDO_REDO),{canRedo:e});}};/**
 * The Redo function - commits the latest undone mutation to the store,
 * and pushes it to the done stack
 *
 * @module store/plugins/undoRedo:redo
 * @function
 */var execRedo = (function(a){var b=a.paths,c=a.store;return(/*#__PURE__*/function(){var a=_asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function a(d){var e,f,g,h,i;return regeneratorRuntime.wrap(function(a){for(;;)switch(a.prev=a.next){case 0:if(e=getConfig(b)(d),!Object.keys(e).length){a.next=15;break}return f=e.undone.reduceRight(function(a,b){var c=a.commits,d=a.undone,e=a.proceed;if(!c.length)c=[b],e=!!b.payload.actionGroup;else if(!e)d=[b].concat(_toConsumableArray(d));else{// Find mutations belonging to the same actionGroup
var f=c[c.length-1],g=f.payload.actionGroup;e=b.payload.actionGroup&&b.payload.actionGroup===g,c=[].concat(_toConsumableArray(e?[b]:[]),_toConsumableArray(c)),d=[].concat(_toConsumableArray(e?[]:[b]),_toConsumableArray(d));}return {commits:c,undone:d,proceed:e}},{commits:[],undone:[],proceed:!0}),g=f.undone,h=f.commits,e.newMutation=!1,i=h.map(/*#__PURE__*/function(){var a=_asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function a(b){var e,f,g;return regeneratorRuntime.wrap(function(a){for(;;)switch(a.prev=a.next){case 0:return e=b.type,f=b.payload,c.commit(e,Array.isArray(f)?_toConsumableArray(f):f.constructor(f)),g=f.redoCallback,a.abrupt("return",{action:g?"".concat(d).concat(g):"",payload:f});case 4:case"end":return a.stop();}},a)}));return function(){return a.apply(this,arguments)}}()),a.t0=pipeActions(c),a.next=8,Promise.all(i);case 8:return a.t1=a.sent,a.next=11,(0, a.t0)(a.t1);case 11:e.done=[].concat(_toConsumableArray(e.done),_toConsumableArray(h)),e.newMutation=!0,setConfig(b)(d,_objectSpread({},e,{undone:g})),updateCanUndoRedo({paths:b,store:c})(d);case 15:case"end":return a.stop();}},a)}));return function(){return a.apply(this,arguments)}}())});/**
 * The Undo function - pushes the latest done mutation to the top of the undone
 * stack by popping the done stack and 'replays' all mutations in the done stack
 *
 * @module store/plugins/undoRedo:undo
 * @function
 */var execUndo = (function(a){var b=a.paths,c=a.store;return(/*#__PURE__*/function(){var a=_asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function a(d){var e,f,g,h,i,j,k;return regeneratorRuntime.wrap(function(a){for(;;)switch(a.prev=a.next){case 0:if(e=getConfig(b)(d),!Object.keys(e).length){a.next=19;break}return f=e.done.reduceRight(function(a,b){var c=a.commits,d=a.done,e=a.proceed;if(!c.length)c=[b],e=!!b.payload.actionGroup;else if(!e)d=[b].concat(_toConsumableArray(d));else{var f=c[c.length-1],g=f.payload.actionGroup;e=b.payload.actionGroup&&b.payload.actionGroup===g,c=[].concat(_toConsumableArray(e?[b]:[]),_toConsumableArray(c)),d=[].concat(_toConsumableArray(e?[]:[b]),_toConsumableArray(d));}return {done:d,commits:c,proceed:e}},{done:[],commits:[],proceed:!0}),g=f.done,h=f.commits,i=h.map(function(a){var b=a.payload;return {action:b.undoCallback?"".concat(d).concat(b.undoCallback):"",payload:b}}),a.next=6,pipeActions(c)(i);case 6:return j=[].concat(_toConsumableArray(e.undone),_toConsumableArray(h)),e.newMutation=!1,c.commit("".concat(d).concat(EMPTY_STATE)),k=g.map(/*#__PURE__*/function(){var a=_asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function a(b){var e;return regeneratorRuntime.wrap(function(a){for(;;)switch(a.prev=a.next){case 0:return c.commit(b.type,Array.isArray(b.payload)?_toConsumableArray(b.payload):b.payload.constructor(b.payload)),e=b.payload.redoCallback,a.abrupt("return",{action:e?"".concat(d).concat(e):"",payload:b.payload});case 3:case"end":return a.stop();}},a)}));return function(){return a.apply(this,arguments)}}()),a.t0=pipeActions(c),a.next=13,Promise.all(k);case 13:return a.t1=a.sent,a.next=16,(0, a.t0)(a.t1);case 16:e.newMutation=!0,setConfig(b)(d,_objectSpread({},e,{done:g,undone:j})),updateCanUndoRedo({paths:b,store:c})(d);case 19:case"end":return a.stop();}},a)}));return function(){return a.apply(this,arguments)}}())});var noop=function(){};var undo=noop;var redo=noop;var scaffoldState=function(a){return _objectSpread({},a,{canUndo:!1,canRedo:!1})};var scaffoldActions=function(a){return _objectSpread({},a,{undo:undo,redo:redo})};var scaffoldMutations=function(a){return _objectSpread({},a,{updateCanUndoRedo:function(a,b){b.canUndo!==void 0&&(a.canUndo=b.canUndo),b.canRedo!==void 0&&(a.canRedo=b.canRedo);}})};var scaffoldStore=function(a){return _objectSpread({},a,{state:scaffoldState(a.state||{}),actions:scaffoldActions(a.actions||{}),mutations:scaffoldMutations(a.mutations||{})})};var createPathConfig=function(a){var b=a.namespace,c=void 0===b?"":b,d=a.ignoreMutations,e=void 0===d?[]:d;return {namespace:c,ignoreMutations:e,done:[],undone:[],newMutation:!0}},mapIgnoreMutations=function(a){var b=a.namespace,c=a.ignoreMutations;return {ignoreMutations:(c||[]).map(function(a){return "".concat(b,"/").concat(a)}).concat("".concat(b,"/").concat(UPDATE_CAN_UNDO_REDO))}},mapPaths=function(a){return a.map(function(a){var b=a.namespace,c=a.ignoreMutations;return createPathConfig(_objectSpread({namespace:"".concat(b,"/")},c?mapIgnoreMutations({namespace:b,ignoreMutations:c}):{}))})},canRedo$1=function(a){return function(b){var c=getConfig(a)(b);return !!Object.keys(c).length&&0<c.undone.length}},canUndo$1=function(a){return function(b){var c=getConfig(a)(b);return !!c&&0<c.done.length}};/**
 * The Undo-Redo plugin module
 *
 * @module store/plugins/undoRedo
 * @function
 * @param {Object} options
 * @param {String} options.namespace - The named vuex store module
 * @param {Array<String>} options.ignoreMutations - The list of store mutations
 * (belonging to the module) to be ignored
 * @returns {Function} plugin - the plugin function which accepts the store parameter
 */var undoRedo = (function(a){return function(b){var c=a.paths?mapPaths(a.paths):[createPathConfig({ignoreMutations:[].concat(_toConsumableArray(a.ignoreMutations||[]),[UPDATE_CAN_UNDO_REDO])})];// NB: Watch all actions to intercept the undo/redo NOOP actions
b.subscribe(function(a){var d=1<a.type.split("/").length,e=d?"".concat(a.type.split("/")[0],"/"):"",f=getConfig(c)(e);if(Object.keys(f).length){var g=f.ignoreMutations,h=f.newMutation,i=f.done;a.type!=="".concat(e).concat(EMPTY_STATE)&&a.type!=="".concat(e).concat(UPDATE_CAN_UNDO_REDO)&&-1===g.indexOf(a.type)&&a.type.includes(e)&&h&&(i.push(a),setConfig(c)(e,_objectSpread({},f,{done:i})),updateCanUndoRedo({paths:c,store:b})(e));}}),b.subscribeAction(/*#__PURE__*/function(){var a=_asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function a(d){var e,f;return regeneratorRuntime.wrap(function(a){for(;;)switch(a.prev=a.next){case 0:e=1<d.type.split("/").length,f=e?"".concat(d.type.split("/")[0],"/"):"",a.t0=d.type,a.next=a.t0==="".concat(f).concat(REDO)?5:a.t0==="".concat(f).concat(UNDO)?9:13;break;case 5:if(!canRedo$1(c)(f)){a.next=8;break}return a.next=8,execRedo({paths:c,store:b})(f);case 8:return a.abrupt("break",14);case 9:if(!canUndo$1(c)(f)){a.next=12;break}return a.next=12,execUndo({paths:c,store:b})(f);case 12:return a.abrupt("break",14);case 13:return a.abrupt("break",14);case 14:case"end":return a.stop();}},a)}));return function(){return a.apply(this,arguments)}}());}});export default undoRedo;export{redo,scaffoldActions,scaffoldMutations,scaffoldState,scaffoldStore,undo};