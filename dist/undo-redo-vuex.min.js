!function(n){var e={};function t(o){if(e[o])return e[o].exports;var a=e[o]={i:o,l:!1,exports:{}};return n[o].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=n,t.c=e,t.d=function(n,e,o){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)t.d(o,a,function(e){return n[e]}.bind(null,a));return o},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=0)}([function(n,e,t){"use strict";t.r(e),t.d(e,"undo",function(){return a}),t.d(e,"redo",function(){return c}),t.d(e,"scaffoldState",function(){return r}),t.d(e,"scaffoldActions",function(){return d}),t.d(e,"scaffoldMutations",function(){return i}),t.d(e,"scaffoldStore",function(){return u});const o=()=>{},a=o,c=o,r=n=>({...n,canUndo:!1,canRedo:!1}),d=n=>({...n,undo:a,redo:c}),i=n=>({...n,updateCanUndoRedo:(n,e)=>{void 0!==e.canUndo&&(n.canUndo=e.canUndo),void 0!==e.canRedo&&(n.canRedo=e.canRedo)}}),u=n=>({...n,state:r(n.state||{}),actions:d(n.actions||{}),mutations:i(n.mutations||{})});e.default=(n=>e=>{const t=({namespace:n="",ignoreMutations:e=[]})=>({namespace:n,ignoreMutations:e,done:[],undone:[],newMutation:!0}),o=n.paths?n.paths.map(({namespace:n,ignoreMutations:e})=>t({namespace:`${n}/`,...e?{ignoreMutations:e.map(e=>`${n}/${e}`).concat(`${n}/updateCanUndoRedo`)}:{}})):[t({ignoreMutations:[...n.ignoreMutations||[],"updateCanUndoRedo"]})],a=n=>o.find(e=>e.namespace===n)||{},c=n=>{const e=a(n);return!!Object.keys(e).length&&e.undone.length>0},r=n=>{const e=a(n);return!!e&&e.done.length>0},d=n=>{const t=r(n),o=c(n);e.commit(`${n}updateCanUndoRedo`,{canUndo:t}),e.commit(`${n}updateCanUndoRedo`,{canRedo:o})},i=n=>n.filter(({action:n})=>!!n).reduce((n,{action:t,payload:o})=>n.then(()=>e.dispatch(t,o)),Promise.resolve()),u=(n,e)=>{const t=o.findIndex(e=>e.namespace===n);o.splice(t,1,e)};e.subscribe(n=>{const e=n.type.split("/").length>1?`${n.type.split("/")[0]}/`:"",t=a(e);if(Object.keys(t).length){const{ignoreMutations:o,newMutation:a,done:c}=t;n.type!==`${e}emptyState`&&n.type!==`${e}updateCanUndoRedo`&&-1===o.indexOf(n.type)&&n.type.includes(e)&&a&&(c.push(n),u(e,{...t,done:c}),d(e))}}),e.subscribeAction(async n=>{const t=n.type.split("/").length>1?`${n.type.split("/")[0]}/`:"";switch(n.type){case`${t}redo`:c(t)&&await(async n=>{const t=a(n);if(Object.keys(t).length){const{undone:o,commits:a}=t.undone.reduceRight(({commits:n,undone:e,proceed:t},o)=>{if(n.length)if(t){const a=n[n.length-1],{actionGroup:c}=a.payload;n=[...(t=o.payload.actionGroup&&o.payload.actionGroup===c)?[o]:[],...n],e=[...t?[]:[o],...e]}else e=[o,...e];else n=[o],t=!!o.payload.actionGroup;return{commits:n,undone:e,proceed:t}},{commits:[],undone:[],proceed:!0});t.newMutation=!1;const c=a.map(async({type:t,payload:o})=>{e.commit(t,Array.isArray(o)?[...o]:o.constructor(o));const{redoCallback:a}=o;return{action:a?`${n}${a}`:"",payload:o}});await i(await Promise.all(c)),t.done=[...t.done,...a],t.newMutation=!0,u(n,{...t,undone:o}),d(n)}})(t);break;case`${t}undo`:r(t)&&await(async n=>{const t=a(n);if(Object.keys(t).length){const{done:o,commits:a}=t.done.reduceRight(({commits:n,done:e,proceed:t},o)=>{if(n.length)if(t){const a=n[n.length-1],{actionGroup:c}=a.payload;n=[...(t=o.payload.actionGroup&&o.payload.actionGroup===c)?[o]:[],...n],e=[...t?[]:[o],...e]}else e=[o,...e];else n=[o],t=!!o.payload.actionGroup;return{done:e,commits:n,proceed:t}},{done:[],commits:[],proceed:!0}),c=a.map(({payload:e})=>({action:e.undoCallback?`${n}${e.undoCallback}`:"",payload:e}));await i(c);const r=[...t.undone,...a];t.newMutation=!1,e.commit(`${n}emptyState`);const s=o.map(async t=>{e.commit(t.type,Array.isArray(t.payload)?[...t.payload]:t.payload.constructor(t.payload));const{redoCallback:o}=t.payload;return{action:o?`${n}${o}`:"",payload:t.payload}});await i(await Promise.all(s)),t.newMutation=!0,u(n,{...t,done:o,undone:r}),d(n)}})(t)}})})}]);